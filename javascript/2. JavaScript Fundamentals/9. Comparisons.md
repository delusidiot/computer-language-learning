# Comparisons

이번파트도 자바스크립트에만 있는 특별한 연산자 외엔 간단히 넘어갑니다.

- 보다 큼·작음: a > b, a < b.
- 보다 크거나·작거나 같음: a >= b, a <= b.
- 같음(동등): a == b. 등호 =가 두 개 연달아 오는 것에 유의하세요. a ​​= b와 같이 등호가 하나일 때는 할당을 의미합니다.
- 같지 않음(부등): 같지 않음을 나타내는 수학 기호 ≠는 자바스크립트에선 a != b로 나타냅니다. 할당연산자 = 앞에 느낌표 !를 붙여서 표시합니다.

다른 연산자와 마찬가지로 비교연산자 역시 값을 반환합니다. 반환 값은 불린형입니다.

`true`또는 `false`가 반환됩니다.

## 문자열 비교

자바스크립트는 사전순으로 문자열을 비교합니다. `lexicographical(사전편집)`순 이라고 불리기도 하는 이 기준을 적용하면 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단됩니다.

```javascript
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

문자열 비교시 적용되는 알고리즘은 다음과 같습니다.

1. 두 문자열의 첫 글자를 비교합니다.
2. 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(작으면), 첫 번째 문자열이 두 번째 문자열보다 크다고(작다고) 결론 내고 비교를 종료합니다.
3. 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교합니다.
4. 글자 간 비교가 끝날 때까지 이 과정을 반복합니다.
5. 비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론 냅니다. 비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 냅니다.

> 정확히는 사전순이 아니라 유니코드 순입니다. JavaScript가 대소문자를 따져 "A"와 "a"를 비교했을 때 "a"가 더 크다고 나오는 이유가 이 때문입니다.

## 다른 형을 가진 값 간의 비교
비교하려는 값의 자료형이 다르면 자바스크립트는 이 값들을 숫자형을 변경합니다.
```javascript
alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행됩니다.
alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행됩니다.
alert( true == 1 ); // true
alert( false == 0 ); // true
```

이렇다보니 일어나지 않은 법한 상황이 동시에 일어나는 흥미로운 경우도 있습니다.
```javascript
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

## 일치연산자
동등 연산자 `==`는 `0`과 `false`를 구별하지 못합니다.
```javascript
alert( 0 == false ); // true
alert( '' == false ); // true
```

이러한 문제는 동등 연산자 `==`가 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문에 발생합니다.

**일치연산자(strict equality operator)** `===`를 사용하면 형 변환 없이 값을 비교할 수 있습니다.

일치 연산자는 엄격한(strict) 동등 연산자입니ㅏㄷ. 자료형의 동등 여부까지 검사하기 때문에, 피연산자 `a`와 `b`의 형이 다를 경우 `a === b`는 `false`를 즉시 반환합니다.

반대로 `!==`는 부등연산자 `!=`의 엄격한 형태입니다. 일치 연산자는 동등 연산자보다 한 글자 더 길긴 하지만 비교 결과가 명확하기 때문에 에러가 발생할 확률을 줄여줍니다.

## `null`이나 `undefined`와 비교

`null`이나 `undefined`를 다른 값과 비교할 땐 예상치 않은 일들이 발생합니다. 일단 몇 가지 규칭을 먼저 살펴본후, 어떤 예상치 않은 일들이 일어나는지 구체적인 예시를 통해 살펴보겠습니다.

### 일치 연산자 `===`를 이용한 비교
두 값의 자료형이 다르기 때문에 일치 비교 시 거짓이 반환됩니다.

### 동등 연산자 `==`를 이용한 비교
동등 연산자를 사용해 비교하면 특별한 규칙이 적용되어 `true`가 반환됩니다. 동등 연산자는 `null`과 `undefined`를 각별한 커플처럼 취급합니다. 두 값은 자기들끼리는 잘 어울리지만 다른 값들과는 잘 어울리지 못합니다.

### 산술 연산자나 기타 비교 연산자 `< > <= >=`를 사용하여 `null`과 `undefined`를 비교
`null`과 `undefined`는 숫자형으로 변환됩니다. `null`은 0, `undefined`는 `NaN`으로 변합니다.

### `null` vs `0`

```javascript
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

위 결과는 논리에 맞지 않습니다. 이는 동등연산자 `==`와 기타 비교 연산자 `< > <= >=`의 동작 방식이 다르기 때문입니다. 비교연산자에서는 `null`이 숫자형으로 변환되어 `0`이되고 동등연산자에서는 `null`이 형변환을 하지 않기 때문에 발생하는 문제입니다.

### 비교가 불가능한 `undefined`

`undefined`를 다른 값과 비교해서는 안 됩니다.

```javascript
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

비교 연산에선 `undefined`가 `NaN`으로 변환되고, `NaN`이 피연산자인 경우 비교연산자는 항상 `false`를 반환합니다.

동등 연산에선 `undefined`는 `null`이나 `undefined`와 같고, 그 이외의 값과는 같지 않기 때문에 `false`를 반환합니다.

### 함정

이선 예외적인 경우를 꼭 기억해 놓고 있어야 할 필요는 없습니다. 개발을 하다 보면 자연스레 이런 경우를 만나고 점차 익숙해 지기 때문입니다.

일치 연산자 `===`를 제외한 비교 연산자의 피연산자에 `undefined`나 `null`이 오지 않도록 특별히 주의하시기 바랍니다.

또한, `undefiend`나 `null`이 될 가능성이 있는 변수가 `>= > < <=`의 피연산자가 되지 않도록 주의하기시 바랍니다. 명확한 의도를 갖고 있지 않은 이상 말이죠.

만일 `undefined`나 `null`이 될 가능성이 있다고 판단되면, 이를 따로 처리하는 코드를 추가하시기 바랍니다.
