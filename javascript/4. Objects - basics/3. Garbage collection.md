# Garbage collection

## 가비지 컬렉션 기준

JavaScript는 눈에 보이지 않는 곳에서 메모리 관리를 수행합니다. JavaScript는 도달 가능성 이라는 개념을 사용해 메모리 관리를 수행합니다.

`reachable(도달 가능한)`값은 쉽게 말해 어떻게든 접근하거나 사용할 수 있는 값을 의미합니다. 도달 가능한 값은 메모리에서 삭제되지 않습니다.

아래는 태생부터 도달 가능하기 때문에 명백한 이유 없이는 삭제되지 않는 값들의 예시입니다.

- 현재 함수의 지역 변수와 매개변수
- 중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수
- 전역 변수
- 등등

이런 값은 루트(root)라고 부릅니다.

루트가 참조하는 값이나 체이닝으로 구트에서 참조할 수 있는 값은 도달 가능한 값이 됩니다.

JavaScript 엔진 내에선 가비지 컬렉터가 끊임없이 동작합니다. 가비지 컬렉터는 모든 객체를 모니터링하고, 도달할 수 없는 객체는 삭제합니다.

```javascript
let user = {
  name: "John"
};
```
전역변수 `"user"`는 `{name: "John"}`이라는 객체를 참조함니다. `user`의 값을 다른 값으로 덮어쓰면 참조가 사라집니다.

```javascript
user = null;
```

이제 `{name: "John"}`는 도달할 수 없는 상태가 되었습니다. `{name: "John"}`에 접근할 방법도, 참조하는 것도 모두 사라졌습니다. 이때 가비지 컬렉터는 `{name: "John"}`에 저장된 데이터를 삭제하고 메모리에서 삭제합니다.

```javascript
// user엔 객체 참조 값이 저장됩니다.
let user = {
  name: "John"
};

let admin = user;
```

이번엔 `user`를 `admin`으로 복사했습니다. 그리고 `user`를 다른 값으로 덮어써 봅시다.

```javascript
user = null;
```

전역 변수 `admin`을 통하면 여전히 객체`{name: "John"}`에 접근할 수 있기 때문에 메모리에서 삭제되지 않습니다. 이상태에서 `admin`마저 다른값으로 덮어쓰면 `{name: "John"}`은 삭제될것입니다.

## 내부 알고리즘

`mark-and-sweep`이라 불리는 가비지 컬렉션 기본 알고리즘에 대해 알아봅니다. 가비지 컬렉션은 대개 다음 단계를 거쳐 수행됩니다.

- 가비지 컬렉터는 루트(root) 정보를 수집하고 이를 `mark(기억)`합니다.
- 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 `mark`합니다.
- `mark`된 모든 객체에 방문하고 그 객체들이 참조하는 객체도 `mark`합니다. 한번 방문한 객체는 전부 `mark`하기 때문에 같은 객체를 다시 방문하는 일은 없습니다.
- 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복합니다.
- `mark`되지 않은 모든 객체를 메모리에서 삭제합니다.

JavaScript엔진은 실행에 영향을 미치지 않으면서 가비지 컬렉션을 더 빠르게 하는 다양한 최적화 기법을 적용합니다.

- **generational collection(세대별 수집)** - 객체를 '새로운 객체'와 '오래된 객체'로 나눕니다. 객체 상당수는 생성 이후 제 역할을 빠르게 수행해 금방 쓸모가 없어지는데, 이런 객체를 '새로운 객체'로 구분합니다. 가비지 컬렉터는 이런 객체를 공격적으로 메모리에서 제거합니다. 일정 시간 이상 동안 살아남은 객체는 '오래된 객체'로 분류하고, 가비지 컬렉터가 덜 감시합니다.

- **incremental collection(점진적 수집)** - 방문해야 할 객체가 많다면 모든 객체를 한 번에 방문하고 `mark`하는데 상당한 시간이 소모됩니다. 가비지 컬렉션에 많은 리소스가 사용되어 실행 속도도 눈에 띄게 느려집니다. JavaScript엔진은 이런 현상을 개선하기 위해 가비지 컬렉션을 여러 부분으로 분리한 다음, 각 부분을 별도로 수행합니다. 작업을 분리하고, 변경 사항을 추적하는 데 추가 작업이 필요하긴 하지만, 긴 지연을 짧은 지연 여러개로 분산시킬 수 있다는 장점이 있습니다.
- **idle-time collection(유휴 시간 수집)** - 가비지 컬렉터는 실행에 주는 형향을 최소화하기 위해 CPU가 유휴 상태일 때에만 가비지 컬렉션을 실행합니다.

이 외에도 다양한 최적화 기법과 가비지 컬렉션 알고리즘이 있습니다.

<br><br><br>

어떤 알고리즘을 사용하는지 궁금하다면 ‘The Garbage Collection Handbook: The Art of Automatic Memory Management’(저자 – R. Jones et al)를 참고하시기 바랍니다.

저수준(low-level) 프로그래밍에 익숙하다면, [A tour of V8: Garbage Collection](http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)을 읽어보세요. V8 가비지 컬렉터에 대한 자세한 내용을 확인해 볼 수 있습니다.

[V8 공식 블로그](https://v8.dev/)에도 메모리 관리 방법 변화에 대한 내용이 올라옵니다. 가비지 컬렉션을 심도 있게 학습하려면 V8 내부구조를 공부하거나 V8 엔지니어로 일했던 [Vyacheslav Egorov의 블로그](https://mrale.ph/)를 읽는 것도 좋습니다. 여러 엔진 중 ‘V8’ 엔진을 언급하는 이유는 인터넷에서 관련 글을 쉽게 찾을 수 있기 때문입니다. V8과 타 엔진들은 동작 방법이 비슷한데, 가비지 컬렉션 동작 방식에는 많은 차이가 있습니다.

저수준 최적화가 필요한 상황이라면, 엔진에 대한 조예가 깊어야 합니다. 먼저 자바스크립트에 익숙해진 후에 엔진에 대해 학습하는 것을 추천해 드립니다.